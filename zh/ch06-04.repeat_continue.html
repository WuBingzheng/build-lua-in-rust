<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>repeat和continue语句 - 用Rust实现Lua解释器</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">前言</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> 编译原理基础</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> 字节码</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> 值和类型</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html"><strong aria-hidden="true">1.4.</strong> 动手实现</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> 变量和赋值</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html"><strong aria-hidden="true">2.1.</strong> 更多类型</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html"><strong aria-hidden="true">2.2.</strong> 局部变量</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> 变量赋值</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> 字符串优化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> 字符串定义</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> 输入类型</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode和UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> 垃圾回收和Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> 表和ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> 表的定义</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> 表的构造</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc概念</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc改造</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> 表的读写和BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> 数值运算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> 一元运算</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html"><strong aria-hidden="true">5.2.</strong> 二元运算</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> 整数和浮点数</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> 控制结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if语句</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif和else分支</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while和break语句</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html" class="active"><strong aria-hidden="true">6.4.</strong> repeat和continue语句</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> 数值型for语句</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto语句</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> 逻辑运算和关系运算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html"><strong aria-hidden="true">7.1.</strong> 条件判断中的逻辑运算</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> 求值中的逻辑运算</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html"><strong aria-hidden="true">7.3.</strong> 条件判断中的关系运算</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> 求值中的关系运算</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> 函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> 定义和调用</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> 参数</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> 返回值</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html"><strong aria-hidden="true">8.4.</strong> Rust函数和API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> 尾调用</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> 闭包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue的逃逸和闭包</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> block和goto的逃逸</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust闭包</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> 泛型for语句</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> 环境 _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">未完待续</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">参考文献</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">用Rust实现Lua解释器</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="repeatuntil和continue语句"><a class="header" href="#repeatuntil和continue语句">repeat..until和continue语句</a></h1>
<p>本节介绍 repeat..until语句，并讨论和尝试引入Lua语言并不支持的continue语句。</p>
<h2 id="repeatuntil语句"><a class="header" href="#repeatuntil语句">repeat..until语句</a></h2>
<p>repeat..until语句跟while语句很像，只不过是把判断条件放在了后面，从而保证内部代码块至少执行一次。</p>
<pre><code>     +--------+
     | repeat |
     +--------+
/---&gt;
|        block
|
|    +-----------------+
\----| until condition |
     +-----------------+
</code></pre>
<p>最终生成的字节码序列的格式如下，其中<code>...</code>代表内部代码块的字节码序列：</p>
<pre><code>    ...  &lt;--\
    Test ---/  until判断条件
</code></pre>
<p>跟while语句的字节码序列相比，看上去就是把Test放到最后，并替换掉原来的Jump字节码。但情况并没有这么简单！把判断条件语句放到block后面，会引入一个问题，判断条件语句中可能会使用block中定义的局部变量。比如下面例子：</p>
<pre><code class="language-lua">-- 如果请求失败，则一直重试，直到成功为止
repeat
    local ok = request_xxx()
until ok
</code></pre>
<p>最后一行until后面的变量<code>ok</code>，本意明显是要引用第二行中定义的局部变量。但是，之前的代码块分析函数<code>block()</code>在函数结尾就已经删除了内部定义的局部变量，代码参见<a href="./ch06-01.if.html#block%E7%9A%84%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">这里</a>。也就是说，按照之前的语法分析逻辑，在解析到<code>until</code>时，内部定义的<code>ok</code>局部变量已经失效，无法使用了。这显然是不可接受的。</p>
<p>为了支持在until时依然能读到内部局部变量，需要修改原来的<code>block()</code>函数（代码就是被这些奇怪的需求搞乱的），把对局部变量的控制独立出来。为此，新增一个<code>block_scope()</code>函数，只做语法分析；而内部局部变量的作用域由外层的<code>block()</code>函数完成。这样原来调用<code>block()</code>函数的地方（比如if、while语句等）就不用修改，而这个特别的repeat..until语句调用<code>block_scope()</code>函数，做更细的控制。代码如下：</p>
<pre><code class="language-rust ignore">    fn block(&amp;mut self) -&gt; Token {
        let nvar = self.locals.len();
        let end_token = self.block_scope();
        self.locals.truncate(nvar); // expire internal local variables
        return end_token;
    }
    fn block_scope(&amp;mut self) -&gt; Token {
        ... // 原有的block解析过程
    }
</code></pre>
<p>然后，repeat..until语句的分析代码如下：</p>
<pre><code class="language-rust ignore">    fn repeat_stat(&amp;mut self) {
        let istart = self.byte_codes.len();

        self.push_break_block();

        let nvar = self.locals.len();  // 内部局部变量作用域控制！

        assert_eq!(self.block_scope(), Token::Until);

        let icond = self.exp_discharge_top();

        // expire internal local variables AFTER condition exp.
        self.locals.truncate(nvar);  // 内部局部变量作用域控制！

        let iend = self.byte_codes.len();
        self.byte_codes.push(ByteCode::Test(icond as u8, -((iend - istart + 1) as i16)));

        self.pop_break_block();
    }
</code></pre>
<p>上述代码中，中文注释的2行，就是完成了原来<code>block()</code>函数中内部局部变量作用域的控制。在调用完<code>exp_discharge_top()</code>解析完条件判断语句之后，才去删除内部定义的局部变量。</p>
<h2 id="continue语句"><a class="header" href="#continue语句">continue语句</a></h2>
<p>上面花了很大篇幅来说明repeat..until语句中变量作用域的问题，这跟Lua中并不存在的continue语句也有很大关系。</p>
<p>在上一节支持break语句时，提到了Lua语言并不支持continue语句。关于这个问题的争论非常多，在Lua中加入continue语句的呼声也很高，早在2012年就有相关的<a href="http://lua-users.org/wiki/ContinueProposal">提案</a>，其中详细罗列了加入continue语句的好处和坏处以及相关讨论。20年过去了，倔强的Lua即使在5.2版本加入了goto语句，也仍然没有加入continue语句。</p>
<p><a href="https://www.luafaq.org/#T1.26">“非官方FAQ”</a>对此的解释是：</p>
<ul>
<li>continue语句只是众多控制语句之一，类似的包括goto、带label的break等。而continue语句并没有什么特殊，没有必要新增这个语句；</li>
<li>跟现有的repeat..until语句冲突。</li>
</ul>
<p>另外，Lua的作者Roberto的一封<a href="http://lua-users.org/lists/lua-l/2008-02/msg01183.html">邮件</a>更能代表官方态度。其中说的原因就是上述第1点，即continue语句只是众多控制语句之一。一个有意思的地方是，这封邮件里举了两个例子，除continue外另外一个例子刚好也是repeat..until。上面非官方FAQ里也提到这两个语句冲突。</p>
<p>这两个语句冲突的原因是，如果repeat..until内部代码块中有continue语句，那么就会跳转到until的条件判断位置；如果条件判断语句中使用了内部定义的局部变量，而continue语句又跳过了这个局部变量的定义，那这个局部变量就没有意义了。这就是冲突所在。比如下面的代码：</p>
<pre><code class="language-lua">repeat
    continue -- 跳转到until，跳过了ok的定义
    local ok = request_xxx()
until ok -- 这里ok如何处理？
</code></pre>
<p>对比下，C语言中跟repeat..until语句等价的是do..while语句，是支持continue的。这是因为C语言的do..while语句中，while后面的条件判断是在内部代码块的作用域<strong>之外</strong>的。比如下面代码就会编译错误：</p>
<pre><code class="language-c">    do {
        bool ok = request_xx();
    } while (ok);  // error: ‘ok’ undeclared
</code></pre>
<p>这样的规范（条件判断是在内部代码块的作用域<strong>之外</strong>）虽然在有的使用场景下不太方便（如上面的例子），但也有很简单的解决方法（比如把<code>ok</code>定义挪到循环外面），而且语法分析也更简单，比如就不需要拆出<code>block_scope()</code>函数了。那Lua为什么规定把条件判断语句放到内部作用域<strong>之内</strong>呢？推测如下，假如Lua也按照C语言的做法（条件判断是在内部代码块的作用域<strong>之外</strong>），然后用户写出下面的Lua代码，until后面的<code>ok</code>就被解析为一个全局变量，而不会像C语言那样报错！这并不是用户的本意，于是造成一个严重的bug。</p>
<pre><code class="language-lua">repeat
    local ok = request_xxx()
until ok
</code></pre>
<p>总结一下，就是repeat..until语句为了避免大概率出现的bug，需要把until后面的条件判断语句放到内部代码块的作用域之内；那么continue语句跳转到条件语句中时，就可能跳过局部变量的定义，进而出现冲突。</p>
<h2 id="尝试添加continue语句"><a class="header" href="#尝试添加continue语句">尝试添加continue语句</a></h2>
<p>Lua官方<a href="https://www.luafaq.org/#T1.26">不支持continue语句的理由</a>主要是他们认为continue语句的使用频率很低，不值得支持。但是在我个人编程经历中，无论是Lua还是其他语言，continue语句的使用频率还是很高的，虽然可能比不上break，但是远超goto和带label的break语句，甚至也超过repeat..until语句。而现在Lua中实现continue功能的方式（repeat..until true加break，或者goto）都比直接使用continue要啰嗦。那么能不能在我们的解释器中增加continue语句呢？</p>
<p>首先，自然是要解决上面说的跟repeat..until的冲突。有几个解决方案：</p>
<ul>
<li>
<p>规定repeat..until中不支持continue语句，就像if语句不支持continue一样。但这样非常容易造成误会。比如一段代码有两层循环，外层是while循环，内层是repeat循环；用户在内层循环中写了continue语句，本意是想在内层repeat循环生效，但由于实际上repeat不支持continue，那么就会在外层while循环生效，continue了外层的while循环。这是严重的潜在bug。</p>
</li>
<li>
<p>规定repeat..until中禁止continue语句，如果有continue则报错，这样可以规避上面方案的潜在bug，但是这个禁止过分严格了。</p>
</li>
<li>
<p>规定repeat..until中如果定义了内部局部变量，则禁止continue语句。这个方案比上个更宽松了些，但可以更加宽松。</p>
</li>
<li>
<p>规定repeat..until中出现continue语句后，就禁止再定义内部局部变量；或者说，continue禁止向局部变量定义之后跳转。这个跟后续的goto语句的限制类似。不过，还可以更加宽松。</p>
</li>
<li>
<p>在上一个方案的基础上，只有until后面的条件判断语句中使用了continue语句后面定义的局部变量，才禁止。只不过判断语句中是否使用局部变量的判定很复杂，如果后续再支持了函数闭包和Upvalue，就基本不可能判定了。所以这个方案不可行。</p>
</li>
</ul>
<p>最终选择使用倒数第2个方案。具体编码实现，原来在<code>ParseProto</code>中有<code>break_blocks</code>用来记录break语句，现在新增类似的<code>continue_blocks</code>，但成员类型是<code>(icode, nvar)</code>。其中第一个变量icode和<code>break_blocks</code>的成员一样，记录continue语句对应的Jump字节码的位置，用于后续修正；第二个变量<code>nvar</code>代表continue语句时局部变量的个数，用于后续检查是否跳转过新的局部变量。</p>
<p>其次，新增continue语句不能影响现有的代码。为了支持continue语句需要把<code>continue</code>作为一个关键字（类似<code>break</code>关键字），那么很多现存Lua代码中使用<code>continue</code>作为label，甚至是变量名或函数名（本质也是变量名）的地方就会解析失败。为此，一个tricky的解决方案是不把<code>continue</code>作为关键字，而是在解析语句时判断如果开头是<code>continue</code>并且后面紧跟块结束Token（比如<code>end</code>等），就认为是continue语句。这样在其他大部分地方，<code>continue</code>仍然会被解释为普通的Name。</p>
<p>对应的<code>block_scope()</code>函数中，以Token::Name开头的部分，新增代码如下：</p>
<pre><code class="language-rust ignore">        loop {
            match self.lex.next() {
                // 省略其他类型语句的解析
                t@Token::Name(_) | t@Token::ParL =&gt; {
                    // this is not standard!
                    if self.try_continue_stat(&amp;t) {  // !! 新增 !!
                        continue;
                    }

                    // 以下省略标准的函数调用和变量赋值语句解析
                }
</code></pre>
<p>其中<code>try_continue_stat()</code>函数定义如下：</p>
<pre><code class="language-rust ignore">    fn try_continue_stat(&amp;mut self, name: &amp;Token) -&gt; bool {
        if let Token::Name(name) = name {
            if name.as_str() != &quot;continue&quot; { // 判断语句开头是&quot;continue&quot;
                return false;
            }
            if !matches!(self.lex.peek(), Token::End | Token::Elseif | Token::Else) {
                return false; // 判断后面紧跟这3个Token之一
            }

            // 那么，就是continue语句。下面的处理跟break语句处理类似
            if let Some(continues) = self.continue_blocks.last_mut() {
                self.byte_codes.push(ByteCode::Jump(0));
                continues.push((self.byte_codes.len() - 1, self.locals.len()));
            } else {
                panic!(&quot;continue outside loop&quot;);
            }
            true
        } else {
            false
        }
    }
</code></pre>
<p>在解析到循环体的代码块block前，要先做准备，是<code>push_loop_block()</code>函数。block结束后，再用<code>pop_loop_block()</code>处理breaks和continues。breaks对应的Jump是跳转到block结束，即当前位置；而continues对应的Jump跳转位置是根据不同循环而定（比如while循环是跳转到循环开始，而repeat循环是跳转到循环结尾），所以需要参数来指定；另外，处理continus时要检查之后有没有新增局部变量的定义，即对比当前局部变量的数量跟continue语句时局部变量的数量。</p>
<pre><code class="language-rust ignore">    // before entering loop block
    fn push_loop_block(&amp;mut self) {
        self.break_blocks.push(Vec::new());
        self.continue_blocks.push(Vec::new());
    }

    // after leaving loop block, fix `break` and `continue` Jumps
    fn pop_loop_block(&amp;mut self, icontinue: usize) {
        // breaks
        let iend = self.byte_codes.len() - 1;
        for i in self.break_blocks.pop().unwrap().into_iter() {
            self.byte_codes[i] = ByteCode::Jump((iend - i) as i16);
        }

        // continues
        let end_nvar = self.locals.len();
        for (i, i_nvar) in self.continue_blocks.pop().unwrap().into_iter() {
            if i_nvar &lt; end_nvar {  // i_nvar为continue语句时局部变量的数量，end_nvar为当前局部变量的数量
                panic!(&quot;continue jump into local scope&quot;);
            }
            self.byte_codes[i] = ByteCode::Jump((icontinue as isize - i as isize) as i16 - 1);
        }
    }
</code></pre>
<p>至此，我们在保证向后兼容情况下，实现了continue语句！可以使用下述代码测试：</p>
<pre><code class="language-lua">-- validate compatibility
continue = print -- continue as global variable name, and assign it a value
continue(continue) -- call continue as function

-- continue in while loop
local c = true
while c do
    print &quot;hello, while&quot;
    if true then
      c = false
      continue
    end
    print &quot;should not print this!&quot;
end

-- continue in repeat loop
repeat
    print &quot;hello, repeat&quot;
    local ok = true
    if true then
      continue -- continue after local
    end
    print &quot;should not print this!&quot;
until ok

-- continue skip local in repeat loop
-- PANIC!
repeat
    print &quot;hello, repeat again&quot;
    if true then
      continue -- skip `ok`!!! error in parsing
    end
    local ok = true
until ok
</code></pre>
<h2 id="repeatuntil的存在"><a class="header" href="#repeatuntil的存在">repeat..until的存在</a></h2>
<p>上面可以看到由于在until部分需要扩展block中定义的局部变量的作用域，repeat..until语句的存在引入了两个问题：</p>
<ul>
<li>编程实现中，需要特意新建<code>block_scope()</code>函数；</li>
<li>跟continue语句有冲突。</li>
</ul>
<p>我个人认为，为了支持repeat..until这么一个使用频率很低的语句而引入上面两个问题，有些得不偿失。如果是我来设计Lua语言，是不会支持这个语句的。</p>
<p>官方的《Lua程序设计（第4版）》一书的 8.4练习 一节中，提出了如下问题：</p>
<blockquote>
<p>练习8.3：很多人认为，由于repeat-until很少使用，因此在想Lua语言这样的简单的编程语言中最后不要出现，你怎么看？</p>
</blockquote>
<p>我是真想知道作者对这个问题的回答，但可惜这本书的练习题都没有给答案。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-03.while_break.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch06-05.numerical-for.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-03.while_break.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch06-05.numerical-for.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
