<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>条件判断中的逻辑运算 - 用Rust实现Lua解释器</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">前言</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> 编译原理基础</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> 字节码</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> 值和类型</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html"><strong aria-hidden="true">1.4.</strong> 动手实现</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> 变量和赋值</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html"><strong aria-hidden="true">2.1.</strong> 更多类型</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html"><strong aria-hidden="true">2.2.</strong> 局部变量</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> 变量赋值</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> 字符串优化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> 字符串定义</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> 输入类型</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode和UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> 垃圾回收和Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> 表和ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> 表的定义</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> 表的构造</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc概念</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc改造</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> 表的读写和BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> 数值运算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> 一元运算</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html"><strong aria-hidden="true">5.2.</strong> 二元运算</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> 整数和浮点数</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> 控制结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if语句</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif和else分支</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while和break语句</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html"><strong aria-hidden="true">6.4.</strong> repeat和continue语句</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> 数值型for语句</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto语句</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> 逻辑运算和关系运算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html" class="active"><strong aria-hidden="true">7.1.</strong> 条件判断中的逻辑运算</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> 求值中的逻辑运算</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html"><strong aria-hidden="true">7.3.</strong> 条件判断中的关系运算</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> 求值中的关系运算</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> 函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> 定义和调用</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> 参数</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> 返回值</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html"><strong aria-hidden="true">8.4.</strong> Rust函数和API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> 尾调用</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> 闭包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue的逃逸和闭包</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> block和goto的逃逸</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust闭包</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> 泛型for语句</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> 环境 _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">未完待续</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">参考文献</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">用Rust实现Lua解释器</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="条件判断中的逻辑运算"><a class="header" href="#条件判断中的逻辑运算">条件判断中的逻辑运算</a></h1>
<p>逻辑运算包括3个：与and、或or、非not。其中最后一个“非not”是一元运算，已经在之前<a href="./ch05-01.unary_ops.html">一元运算</a>一节中介绍过了。本章只介绍前面两个“与and”和“或or”。</p>
<p>那为什么没有在之前的<a href="./ch05-02.binary_ops.html">二元运算</a>一节中介绍与and和或or呢？因为“短路”！在主流编程语言（比如C、Rust）中逻辑运算都是短路的。比如对于与and运算，如果第一个操作数是false，那么就没必要（也不能）求第二个操作数了。比如语句<code>is_valid() and count()</code>，假如<code>is_valid()</code>的返回值是false，那么就不能执行后续的<code>count()</code>。所以，逻辑运算的执行过程是：1.先判断左操作数，2.如果是false则退出，3.否则判断右操作数。而之前介绍二元数值运算的执行过程是：1.先求左操作数，2.再求右操作数，3.最后计算。可见逻辑运算跟数值运算的流程不同，不能套用之前的做法。</p>
<p>在具体介绍逻辑运行之前，先来看逻辑运算的两个使用场景：</p>
<ol>
<li>作为判断条件，比如上一章中if、while等语句中的判断条件语句，比如<code>if t and t.k then ... end</code>；</li>
<li>求值，比如<code>print(v&gt;0 and v or -v)</code>。</li>
</ol>
<p>其实第1种场景可以看做是第2种场景的一种特殊情况。比如上述的if语句例子，就等价于下面的代码：</p>
<pre><code class="language-lua">local tmp = t and t.k
if tmp then
    ...
end
</code></pre>
<p>就是先对<code>t and t.k</code>这个运算语句进行求值，然后把值放到临时变量中，最后再判断这个值的真假来决定是否跳转。但是，这里我们其实并不关心具体的求值结果是<code>t</code>还是<code>t.k</code>，而只关心true或者false，所以可以省去临时变量！下面可以看到省去临时变量可以省掉一个字节码，是很大的优化。由于逻辑运算大部分应用是第1种场景，所以是值得把这个场景从第2种通用场景中独立出来特地做优化的，通过省去临时变量，直接根据求值结果来判断是否跳转。</p>
<p>如本节标题所示，本节只介绍第1种场景；下一节再介绍第2种场景。</p>
<h2 id="跳转规律"><a class="header" href="#跳转规律">跳转规律</a></h2>
<p>上面介绍了逻辑运算的短路特性，在每次判断完一个操作数后，都可能发生跳转，跳过下一个操作数。逻辑运算最终对应的字节码，就是根据每个操作数做跳转。不同的运算组合就会导致各种各样的跳转组合。现在就要从各种跳转组合中归纳出跳转规律，以便用作后续的解析规则。这可能是整个解释器中最绕的一部分。</p>
<p>下面都用最简单的if语句作为应用场景，并先看最基础的and和or运算。下面两图分别是<code>if A and B then ... end</code>和<code>if X or Y then ... end</code>的跳转示意图：</p>
<pre><code> A and B                      X or Y

+-------+                    +-------+
|   A   +-False-\    /--True-+   X   |
+---+---+       |    |       +---+---+
    |True       |    |           |False
    V           |    |           V
+-------+       |    |       +-------+
|   B   +-False&gt;+    |       |   Y   +-False-\
+---+---+       |    |       +---+---+      |
    |True       |    \----------&gt;|True      |
    V           |                V          |
  block         |              block        |
    |           |                |          |
    +&lt;----------/                +&lt;--------/
    V                            V
</code></pre>
<p>左图是与and运算。两个操作数A和B判断后的处理一样，都是True则继续执行；False则跳转到代码块结尾。</p>
<p>右图是或or运算。两个操作数的处理流程不一样。第一个操作数X的处理是：False则继续执行，True则跳转到下面代码块开始。而第二个操作数Y的处理跟之前A、B的处理方式一样。</p>
<p>不过只看这两个例子是总结不出通用规律的。还需要看些复杂的：</p>
<pre><code>A and B and C               X or Y or Z                 (A and B) or Y               A and (X or Y)

+-------+                    +-------+                    +-------+                    +-------+
|   A   +-False-\    /--True-+   X   |                    |   A   |-False-\            |   A   +-False-\
+---+---+       |    |       +---+---+                    +---+---+       |            +---+---+       |
    |True       |    |           |False                       |True       |                |True       |
    V           |    |           V                            V           |                V           |
+-------+       |    |       +-------+                    +-------+       |            +-------+       |
|   B   +-False&gt;+    +&lt;-True-+   Y   |            /--True-+   B   |       |    /--True-+   X   |       |
+---+---+       |    |       +---+---+            |       +---+---+       |    |       +---+---+       |
    |True       |    |           |False           |      False|&lt;---------/     |           |False      |
    V           |    |           V                |           V                |           V           |
+-------+       |    |       +-------+            |       +-------+            |       +-------+       |
|   C   +-False&gt;+    |       |   Z   +-False-\    |       |   Y   +-False-\    |       |   Y   +-False&gt;+
+---+---+       |    |       +---+---+       |    |       +---+---+       |    |       +---+---+       |
    |True       |    \----------&gt;|True       |    \----------&gt;|True       |    \----------&gt;|True       |
    V           |                V           |                V           |                V           |
  block         |              block         |              block         |              block         |
    |           |                |           |                |           |                |           |
    +&lt;---------/                 +&lt;----------/                +&lt;---------/                 +&lt;---------/
    V                            V                            V                            V
</code></pre>
<p>根据这4个图可以归纳如下规律（这里省略了归纳的具体步骤。实际中可能需要更多的例子才能归纳，但是举太多例子又太多臃肿）：</p>
<ul>
<li>
<p>跳转条件取决于语句（比如上面例子中的A,B,X,Y等）后面的逻辑运算符（也就是and或者or）：</p>
<ul>
<li>
<p>如果后面跟<code>and</code>运算，则False跳转而True继续执行。比如第1个图中的A和B，后面都是and运算，所以都是False跳转。</p>
</li>
<li>
<p>如果后面跟<code>or</code>运算，则True跳转而False继续执行。比如第2个图中的X和Z，后面都是or运算，所以都是True跳转。</p>
</li>
<li>
<p>如果后面没有逻辑运算符，也就是整条判断语句结束，则False跳转而True继续执行。这个规则跟上面<code>and</code>的相同。上面4个图最后一个判断语句都是如此。</p>
</li>
</ul>
</li>
<li>
<p>跳转目标位置的规则：</p>
<ul>
<li>
<p>如果连续相同的跳转条件，则跳转到同样位置。比如第1个图中连续3个False跳转，第2个图中连续2个True跳转；而第3个图中的两个False跳转并不连续，所以跳转位置不同。那么在语法分析时，如果两个操作数具有相同的跳转条件，就合并跳转列表。</p>
</li>
<li>
<p>如果遇到不同的跳转条件，则终结前面的跳转列表，并跳转到当前判断语句之后。比如第2个图中Z的False终结前面的两个True的跳转列表，并跳转到Z语句后面；再比如第3个图中B的True终结之前的False跳转列表，并跳转到B语句后面。</p>
</li>
<li>
<p>不过第4个图貌似没有遵守上述两条规则，两个False跳转并不连续但也连起来了，或者说X的True跳转并没有终结A的False跳转列表。这是因为A并不是跟<code>X</code>运算，而是跟<code>(X or Y)</code>运算；要先求<code>(X or Y)</code>，此时X的True跳转是全新的，并不知道前面的A的False跳转列表；然后再求<code>A and (X or Y)</code>时，就是True和False两个跳转列表并存了；最终语句结束的False，合并之前A的False跳转列表，并终结X的True跳转列表。</p>
</li>
<li>
<p>判断语句的结束对应的是False跳转，所以会终结True跳转列表，并继续False跳转列表。在block结束后，终结False跳转列表到block结尾。上面4个图中都是如此。</p>
</li>
</ul>
</li>
</ul>
<p>至此，介绍完准备知识。下面开始编码实现。</p>
<h2 id="字节码"><a class="header" href="#字节码">字节码</a></h2>
<p>上一章控制结构的几个条件判断语句，包括if、while、和repeat..until等，对判断条件的处理都是False跳转，所以只有一个测试并跳转的字节码，即<code>Test</code>。而现在需要2种跳转，False跳转和True跳转。为此我们去掉之前的<code>Test</code>，并新增2个字节码：</p>
<pre><code class="language-rust ignore">pub enum ByteCode {
    TestAndJump(u8, i16),  // 如果Test为True，则Jump。
    TestOrJump(u8, i16),   // 如果Test为False，则Jump。跟上一章的`Test`功能相同。
</code></pre>
<p>命名中的“And”和“Or”，跟本节介绍的逻辑运算并无关系，而是源自Rust语言中Option和Error类型的方法名，分别是“那么就”和“否则就”的意思。不过本节最开头的两个例子中，<code>t and t.k</code>可以描述为：如果t存在“那么就”取t.k，<code>t.k or 100</code>可以描述为：如果t.k存在就取其值“否则就”取100。也可以说是相关联的。</p>
<p>只不过上面介绍的跳转规则第1条，如果后面跟<code>and</code>运算，则False跳转，对应的是<code>TestOrJump</code>。这里的<code>and</code>和<code>Or</code>没有对应上，不过关系不大。</p>
<p>官方Lua实现中，仍然只是一条字节码<code>TEST</code>，关联两个参数分别是：判断条件的栈地址（跟我们的一样），和跳转条件（True跳转还是False跳转）。而具体的跳转位置，则需要再加一条无条件跳转的<code>JUMP</code>字节码。看上去2条字节码不太高效。这么做是为了跟另外一个应用场景，在下一节中介绍。</p>
<h2 id="expdesc"><a class="header" href="#expdesc">ExpDesc</a></h2>
<p>在解析逻辑运算符生成跳转字节码时，还不知道跳转的目的位置。只能先生成一个字节码占位，而留空跳转位置的参数。在后续确定目的位置后再填补参数。这个做法跟上一章介绍控制结构时是一样的。而不一样的是，上一章里只会有1个跳转字节码，而这次可能会出现多个字节码拉链的情况，比如上面的第1个图，3个字节码跳转到同一位置。这个拉链可能是True跳转，也可能是False跳转，也可能这两条链同时存在，比如上面第4个图中解析到Y时候。所以需要一个新的ExpDesc类型来保存跳转链表。为此，新增<code>Test</code>类型，定义如下：</p>
<pre><code class="language-rust ignore">enum ExpDesc {
    Test(usize, Vec&lt;usize&gt;, Vec&lt;usize&gt;), // (condition, true-list, false-list)
</code></pre>
<p>关联3个参数。第1个是判断条件在栈上的位置，无论什么类型（常量、变量、表索引等）都会先discharge到栈上，然后再判断真假。后面2个参数是True和False这2条跳转链表，内容分别是需要补齐的字节码的位置。</p>
<p>Lua官方实现中，跳转表是通过跳转字节码中留空的参数来实现的。比如上面第1个图中连续3个False的跳转，判断A、B、C生成的字节码分别是<code>JUMP 0</code>, <code>JUMP $A</code>, <code>JUMP $B</code>，然后在ExpDesc中保存<code>$C</code>。这样通过<code>$C</code>就可以找到<code>$B</code>，通过<code>$B</code>就可以找到<code>$A</code>，而参数<code>0</code>表示链表末尾。最后一边遍历，一边统一修复为<code>JUMP $end</code>。这种设计很高效，无需额外存储，利用暂时留空的Jump参数就可以实现拉链。同时也略显晦涩，容易出错。这种充分利用资源，按bit微操内存，是很典型的C语言项目的做法。而Rust语言标准库中提供了列表Vec，虽然会产生在堆上的内存分配，稍微影响性能，但是逻辑清晰很多，一目了然。只要不是性能瓶颈，就应该尽量避免晦涩而危险的做法，尤其是在使用追求安全的Rust语言时。</p>
<h2 id="语法分析代码"><a class="header" href="#语法分析代码">语法分析代码</a></h2>
<p>现在终于可以语法分析了。从<code>exp()</code>函数的二元运算部分开始。之前介绍二元数值运算的<a href="./ch05-02.binary_ops.html#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F">求值顺序</a>，要先处理第一个操作数。本节开头也介绍了，对于逻辑运算的处理顺序，由于短路的特性，也要先处理第一个操作和可能的跳转，然后才能解析第二个操作数。所以，在继续解析第二个操作数前，先处理跳转：</p>
<pre><code class="language-rust ignore">    fn preprocess_binop_left(&amp;mut self, left: ExpDesc, binop: &amp;Token) -&gt; ExpDesc {
        match binop {
            Token::And =&gt; ExpDesc::Test(0, Vec::new(), self.test_or_jump(left)),
            Token::Or =&gt; ExpDesc::Test(0, self.test_and_jump(left), Vec::new()),

            _ =&gt; // 省略discharge其他类型的部分
        }
    }
</code></pre>
<p>这个函数中，新增了对逻辑运算的处理部分。以and为例，生成<code>ExpDesc::Test</code>类型，临时保存处理后的2条跳转列表，而关联的第1个参数没有用，这里填0。调用<code>test_or_jump()</code>函数来处理跳转列表。按照上面介绍的规则，and运算符对应的是False跳转，是会终结之前的True跳转列表，所以<code>test_or_jump()</code>函数会终结之前的True跳转列表，并只返回False跳转列表。那么这里就新建一个列表<code>Vec::new()</code>作为True跳转列表。</p>
<p>再看<code>test_or_jump()</code>的具体实现：</p>
<pre><code class="language-rust ignore">    fn test_or_jump(&amp;mut self, condition: ExpDesc) -&gt; Vec&lt;usize&gt; {
        let (icondition, true_list, mut false_list) = match condition {
            // 为True的常量，无需测试或者跳转，直接跳过。
            // 例子：while true do ... end
            ExpDesc::Boolean(true) | ExpDesc::Integer(_) | ExpDesc::Float(_) | ExpDesc::String(_) =&gt; {
                return Vec::new();
            }

            // 第一个操作数已经是Test类型，说明这不是第一个逻辑运算符。
            // 直接返回已有的两个跳转列表即可。
            ExpDesc::Test(icondition, true_list, false_list) =&gt;
                (icondition, Some(true_list), false_list),

            // 第一个操作数是其他类型，说明这是第一个逻辑运算符。
            // 只需要discharge第一个操作数到栈上即可。
            // 之前也没有True跳转列表，所以返回None。
            // 也没有False跳转列表，所以新建一个列表，用来保存本次跳转指令。
            _ =&gt; (self.discharge_any(condition), None, Vec::new()),
        };

        // 生成TestOrJump，但第二个参数留空
        self.byte_codes.push(ByteCode::TestOrJump(icondition as u8, 0));

        // 把刚生成的字节码，假如到False跳转列表中，以便后续修复
        false_list.push(self.byte_codes.len() - 1);

        // 终结之前的True跳转列表，并跳转到这里，如果有的话
        if let Some(true_list) = true_list {
            self.fix_test_list(true_list);
        }

        // 返回False跳转列表
        false_list
    }
</code></pre>
<p>对于or运算符和对应的<code>test_and_jump()</code>函数，大同小异，只是翻转下True和False跳转列表。这里不再介绍。</p>
<p>处理完第一个操作数和跳转后，再来处理第二个操作数就很简单了，只需要连接跳转列表即可：</p>
<pre><code class="language-rust ignore">    fn process_binop(&amp;mut self, binop: Token, left: ExpDesc, right: ExpDesc) -&gt; ExpDesc {
        match binop {
            // 省略其他二元运算符处理
            Token::And | Token::Or =&gt; {
                // 第一个操作数已经在上面的preprocess_binop_left()中被转换为ExpDesc::Test
                if let ExpDesc::Test(_, mut left_true_list, mut left_false_list) = left {
                    let icondition = match right {
                        // 如果第二个操作数也是Test类型，比如本节上面第4个图中`A and (X or Y)`的例子，
                        // 那么分别连接两个跳转列表。
                        ExpDesc::Test(icondition, mut right_true_list, mut right_false_list) =&gt; {
                            left_true_list.append(&amp;mut right_true_list);
                            left_false_list.append(&amp;mut right_false_list);
                            icondition
                        }
                        // 如果第二个操作数是其他类型，则无需处理跳转链表
                        _ =&gt; self.discharge_any(right),
                    };

                    // 返回连接后想新跳转列表
                    ExpDesc::Test(icondition, left_true_list, left_false_list)
                } else {
                    panic!(&quot;impossible&quot;);
                }
            }
</code></pre>
<p>处理完二元运算部分，接下来就是应用场景。本节只介绍作为判断条件的应用场景，而在下一节中再介绍求值。上一章中的几个控制结构语句（if、while、repeat..until等）都是直接处理跳转字节码，代码逻辑类似。本节开头介绍的跳转规则中，整条逻辑运算的判断语句结束，是False跳转，所以调用刚才介绍的test_or_jump()函数处理，可以代替并简化上一章的直接处理字节码的代码逻辑。这里仍然用if语句为例：</p>
<pre><code class="language-rust ignore">    fn do_if_block(&amp;mut self, jmp_ends: &amp;mut Vec&lt;usize&gt;) -&gt; Token {
        let condition = self.exp();

        // 上一章，这里是生成Test字节码。
        // 现在，替换并简化为test_or_jump()函数。
        // 终结True跳转列表，并返回新的False跳转列表。
        let false_list = self.test_or_jump(condition);

        self.lex.expect(Token::Then);

        let end_token = self.block();

        if matches!(end_token, Token::Elseif | Token::Else) {
            self.byte_codes.push(ByteCode::Jump(0));
            jmp_ends.push(self.byte_codes.len() - 1);
        }

        // 上一章，这里是修复刚才生成的一条Test字节码。
        // 现在，需要修改一条False跳转列表。
        self.fix_test_list(false_list);

        end_token
    }
</code></pre>
<p>至此完成语法分析部分。</p>
<h2 id="虚拟机执行"><a class="header" href="#虚拟机执行">虚拟机执行</a></h2>
<p>虚拟机执行部分，首先是要处理新增的2个字节码，都很简单，这里忽略不讲。需要讲的是一个栈操作的细节。之前向栈上赋值时的函数如下：</p>
<pre><code class="language-rust ignore">    fn set_stack(&amp;mut self, dst: u8, v: Value) {
        let dst = dst as usize;
        match dst.cmp(&amp;self.stack.len()) {
            Ordering::Equal =&gt; self.stack.push(v),
            Ordering::Less =&gt; self.stack[dst] = v,
            Ordering::Greater =&gt; panic!(&quot;fail in set_stack&quot;),
        }
    }
</code></pre>
<p>首先判断目标地址dst是否在栈的范围内：</p>
<ul>
<li>如果在，则直接赋值；</li>
<li>如果不在并且刚好是下一个位置，则使用<code>push()</code>压入栈中；</li>
<li>如果不在，并且超过下一个位置，之前是不可能出现的，所以调用<code>panic!()</code>。</li>
</ul>
<p>但是逻辑运算的短路特性，是可能导致上述第3种情况出现的。比如下面的语句：</p>
<pre><code class="language-lua">if (g1 or g2) and g3 then
end
</code></pre>
<p>按照我们的解析方式，会生成如下临时变量，占用栈上位置：</p>
<pre><code>|      |
+------+
|  g1  |
+------+
|  g2  |
+------+
|  g3  |
+------+
|      |
</code></pre>
<p>但在执行过程中，如果<code>g1</code>为真，则会跳过对<code>g2</code>的处理，而直接处理<code>g3</code>，此时上图中g2的位置并未设置，那么g3就会超过栈顶的位置，如下图所示：</p>
<pre><code>|      |
+------+
|  g1  |
+------+
|      |
:      :
:      : &lt;-- 设置g3，超过栈顶位置
</code></pre>
<p>所以，要修改上述<code>set_stack()</code>函数，支持设置超过栈顶的元素。这可以通过调用<code>set_vec()</code>实现。</p>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>至此，完成了逻辑运算在条件判断中的应用场景。可以通过本节开头的几个图中的例子来测试。这里省略。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-00.logical_relational.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch07-02.logical_in_evalue.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-00.logical_relational.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch07-02.logical_in_evalue.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
