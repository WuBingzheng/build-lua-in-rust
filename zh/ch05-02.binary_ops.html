<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>二元运算 - 用Rust实现Lua解释器</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">前言</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> 编译原理基础</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> 字节码</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> 值和类型</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html"><strong aria-hidden="true">1.4.</strong> 动手实现</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> 变量和赋值</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html"><strong aria-hidden="true">2.1.</strong> 更多类型</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html"><strong aria-hidden="true">2.2.</strong> 局部变量</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> 变量赋值</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> 字符串优化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> 字符串定义</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> 输入类型</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode和UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> 垃圾回收和Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> 表和ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> 表的定义</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> 表的构造</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc概念</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc改造</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> 表的读写和BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> 数值运算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> 一元运算</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html" class="active"><strong aria-hidden="true">5.2.</strong> 二元运算</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> 整数和浮点数</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> 控制结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if语句</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif和else分支</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while和break语句</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html"><strong aria-hidden="true">6.4.</strong> repeat和continue语句</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> 数值型for语句</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto语句</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> 逻辑运算和关系运算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html"><strong aria-hidden="true">7.1.</strong> 条件判断中的逻辑运算</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> 求值中的逻辑运算</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html"><strong aria-hidden="true">7.3.</strong> 条件判断中的关系运算</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> 求值中的关系运算</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> 函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> 定义和调用</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> 参数</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> 返回值</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html"><strong aria-hidden="true">8.4.</strong> Rust函数和API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> 尾调用</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> 闭包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue的逃逸和闭包</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> block和goto的逃逸</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust闭包</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> 泛型for语句</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> 环境 _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">未完待续</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">参考文献</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">用Rust实现Lua解释器</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="二元运算"><a class="header" href="#二元运算">二元运算</a></h1>
<p>二元运算相对于上一节的一元运算，虽然只是多了一个操作数，但引入了很多问题，主要包括BNF左递归，优先级，操作数类型、和求值顺序等。</p>
<h2 id="bnf左递归"><a class="header" href="#bnf左递归">BNF左递归</a></h2>
<p>Lua中二元运算语句的完整语法如下：</p>
<pre><code>exp ::=  nil | false | true | Numeral | LiteralString | ‘...’ | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 
</code></pre>
<p>简单起见，其他部分简化为<code>OTHERS</code>，得到：</p>
<pre><code>exp ::= exp binop exp | OTHERS
</code></pre>
<p>是左递归规则，需要按照之前介绍的方法来<a href="./ch04-05.table_rw_and_bnf.html#%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92">消除左递归</a>，得到：</p>
<pre><code>exp ::= OTHERS A'
A' := binop exp A' | Epsilon
</code></pre>
<p>之前的<code>exp()</code>函数只是实现了上面第一行的<code>OTHERS</code>部分，现在要加上第二行的<code>A'</code>部分，也是递归引用，使用循环来实现。修改<code>exp()</code>函数结构如下：</p>
<pre><code class="language-rust ignore">    fn exp(&amp;mut self) -&gt; ExpDesc {
        // OTHERS
        let mut desc = match self.lex.next() {
            // 这里省略原有的各种OTHERS类型处理
        };

        // A' := binop exp A' | Epsilon
        while is_binop(self.lex.peek()) {
            let binop = self.lex.next();  // 运算符
            let right_desc = self.exp();  // 第二个操作数
            desc = self.process_binop(binop, desc, right_desc);
        }
        desc
    }
</code></pre>
<p>其中对第二个操作数right_desc也是递归调用<code>exp()</code>函数来读取，这就导致一个问题：优先级。</p>
<h2 id="优先级"><a class="header" href="#优先级">优先级</a></h2>
<p>上一节的一元运算语句中，也是递归调用<code>exp()</code>函数来读取操作数，但因为只有一个操作数，所以并不需要优先级，或者说所有一元运算符的优先级都相等。并且一元运算符都是右结合的。比如下面两个连续一元运算的例子，都是按照从右向左的顺序执行，而跟具体运算符无关：</p>
<ul>
<li><code>~ -10</code>，先取负，再按位取反，</li>
<li><code>- ~10</code>，先按位取反，再取负。</li>
</ul>
<p>但对于二元运算语句，就要考虑优先级了。比如下面两个语句：</p>
<ul>
<li><code>a + b - c</code>，先执行前面的加法，再执行后面的减法，</li>
<li><code>a + b * c</code>，先执行后面的乘法，再执行前面的加法。</li>
</ul>
<p>对应到上面的<code>exp()</code>函数代码中，开头的<code>OTHERS</code>部分读取到第一个操作数<code>a</code>；然后<code>while</code>循环内读取到运算符<code>+</code>；再然后递归调用<code>exp()</code>函数读取右操作数，此时就需要计较下。还以上面两个语句为例：</p>
<ul>
<li><code>a + b - c</code>，读到<code>b</code>就结束并作为右操作数；然后执行加法<code>a + b</code>；然后再次循环处理后面的<code>- c</code>部分；</li>
<li><code>a + b * c</code>，读到<code>b</code>之后还要继续往下，读取并执行整个<code>b * c</code>并将执行结果作为右操作数；然后执行加法；并结束循环。</li>
</ul>
<pre><code>     -             +
   /   \         /   \
  +     c       a     *
/   \               /   \
a   b               b   c
</code></pre>
<p>那么在语法分析时，如何判断是上述哪种情况？读到<code>b</code>后，是停止解析先算加法，还是继续解析？这取决于下一个运算符和当前运算符的优先级：</p>
<ul>
<li>下一个运算符优先级<strong>不大于</strong>当前运算符时，就是第一种情况，停止解析，而先完成当前的运算；</li>
<li>下一个运算符优先级<strong>大于</strong>当前运算符时，就是第二种情况，需要继续解析。</li>
</ul>
<p>为此，参考Lua语言中给所有<a href="https://www.lua.org/manual/5.4/manual.html#3.4.8">运算符优先级</a>列表：</p>
<pre><code>or
and
&lt;     &gt;     &lt;=    &gt;=    ~=    ==
|
~
&amp;
&lt;&lt;    &gt;&gt;
..
+     -
*     /     //    %
unary operators (not   #     -     ~)
^
</code></pre>
<p>由上往下，优先级依次变高。其中连接符<code>..</code>和求幂<code>^</code>都是右结合，其他运算符都是左结合。上面列出的判断规则里，对于相等优先级的情况是停止解析（而非继续解析），所以默认是左结合。于是对于2个右结合的运算符需要特殊处理，即给他们向左和向右定义不同的优先级，向左的更高，这样就会变成右结合。</p>
<p>综上，定义优先级函数：</p>
<pre><code class="language-rust ignore">fn binop_pri(binop: &amp;Token) -&gt; (i32, i32) {
    match binop {
        Token::Pow =&gt; (14, 13), // right associative
        Token::Mul | Token::Mod | Token::Div | Token::Idiv =&gt; (11, 11),
        Token::Add | Token::Sub =&gt; (10, 10),
        Token::Concat =&gt; (9, 8), // right associative
        Token::ShiftL | Token::ShiftR =&gt; (7, 7),
        Token::BitAnd =&gt; (6, 6),
        Token::BitNot =&gt; (5, 5),
        Token::BitOr =&gt; (4, 4),
        Token::Equal | Token::NotEq | Token::Less | Token::Greater | Token::LesEq | Token::GreEq =&gt; (3, 3),
        Token::And =&gt; (2, 2),
        Token::Or =&gt; (1, 1),
        _ =&gt; (-1, -1)
    }
}
</code></pre>
<p>对于不是二元运算符的Token，则返回<code>-1</code>，即最低的优先级，无论当前运算符是什么，都可以停止解析。按照Rust的习惯做法，这个函数应该返回<code>Option&lt;(i32, i32)&gt;</code>类型，然后不是二元运算符的Token就返回<code>None</code>。但是返回<code>-1</code>在调用的地方更简单，不需要多一次Option的处理。</p>
<p>这个函数看上去是<code>Token</code>类型的属性，所以貌似适合定义为<code>Token</code>的方法。但<code>Token</code>类型是在<code>lex.rs</code>中定义的；而优先级是语法分析的概念，应该在<code>parse.rs</code>中实现。Rust语言不允许在类型的非定义的文件中添加方法。所以上述函数就在<code>parse.rs</code>文件中定义为个普通函数（而非其他函数那样是<code>ParseProto</code>的方法）。</p>
<p>现在，按照优先级，再次修改<code>exp()</code>函数：</p>
<pre><code class="language-rust ignore">    fn exp(&amp;mut self) -&gt; ExpDesc {
        self.exp_limit(0)
    }
    fn exp_limit(&amp;mut self, limit: i32) -&gt; ExpDesc {
        // OTHERS
        let mut desc = match self.lex.next() {
            // 这里省略原有的各种OTHERS类型处理
        };

        // A' := binop exp A' | Epsilon
        loop {
            let (left_pri, right_pri) = binop_pri(self.lex.peek());
            if left_pri &lt;= limit {
                return desc;  // 停止解析
            }

            // 继续解析
            let binop = self.lex.next();
            let right_desc = self.exp_limit(right_pri);
            desc = self.process_binop(binop, desc, right_desc);
        }
    }
</code></pre>
<p>首先为<code>exp()</code>增加一个<code>limit</code>参数，作为当前运算符的优先级，限制后续的解析范围。但这个参数属于语句内部概念，对于此函数的调用者而言，无需知晓此参数；所以增加<code>exp_limit()</code>这个实际处理函数，而把<code>exp()</code>变成一个外层封装函数，用<code>limit=0</code>来调用前者。初始调用之所以使用<code>limit=0</code>，是因为<code>0</code>小于<code>binop_pri()</code>函数中定义的任何二元运算符优先级，所以第一个运算符都会被继续解析（而不是return退出循环）；但<code>0</code>又大于非运算符的优先级<code>-1</code>，所以如果后面紧跟非运算符，也会正常退出。</p>
<p>上述解析代码结合了循环和递归调用，对于不熟悉算法的人来说难度很大，很难直接写出完整代码。但是依照消除左递归后的BNF规范，就可以完成循环和递归，再根据优先级加上条件退出，就可以很轻松完成这个函数。</p>
<p>另外，需要注意到上面运算符优先级表单中也列出了一元运算符，所以上一节解析一元运算语句时，读取操作数的表达式时，就不能使用<code>exp()</code>函数（初始优先级0），而应该指定初始优先级为12：</p>
<pre><code class="language-rust ignore">    fn exp_unop(&amp;mut self) -&gt; ExpDesc {
        self.exp_limit(12) // 12 is all unary operators' priority
    }
</code></pre>
<p>求幂运算<code>^</code>的优先级居然高于一元运算符，所以语句<code>-a^10</code>的执行顺序是：先求幂，再取负。</p>
<h2 id="求值顺序"><a class="header" href="#求值顺序">求值顺序</a></h2>
<p>上述解析代码有个非常隐晦的bug，是关于操作数求值的顺序。</p>
<p>每个操作数的处理需要2步：首先调用<code>exp()</code>函数读取操作数并返回ExpDesc，然后调用<code>discharge()</code>函数把操作数discharge到栈上以便字节码操作。二元运算有2个操作数，就一共需要4步。现在讨论下这4步的顺序。</p>
<p>按照当前版本的<code>exp()</code>函数中对二元运算的处理逻辑：</p>
<ul>
<li>先读取第一个操作数，<code>desc</code>；</li>
<li>然后判断是二元运算后，递归调用<code>exp_limit()</code>，读取第二个操作数，<code>right_desc</code>；</li>
<li>然后在<code>process_binop()</code>函数中把上述两个操作数的ExpDesc一起discharge到栈上。</li>
</ul>
<p>简化下就是：</p>
<ul>
<li>解析第一个操作数；</li>
<li>解析第二个操作数；</li>
<li>discharge第一个操作数；</li>
<li>discharge第二个操作数。</li>
</ul>
<p>在解析和discharge阶段，都可能生成字节码。所以按照这个顺序，两个操作数相关的字节码是可能穿插的。比如下面的例子：</p>
<pre><code class="language-lua">local a = -g1 + -g2
</code></pre>
<p>忽略前面的局部变量定义，也忽略未定义全局变量的运算会抛异常，这里重点只看后面的加法语句。用当前版本的解释器生成如下字节码序列：</p>
<pre><code>constants: ['g1', 'g2']
byte_codes:
  GetGlobal(0, 0)  # 解析第一个操作数
  GetGlobal(1, 1)  # 解析第二个操作数
  Neg(2, 0)        # discharge第一个操作数
  Neg(3, 1)        # discharge第二个操作数
  Add(0, 2, 3)
</code></pre>
<p>可以看到这里两个操作数相关的字节码是穿插的。在这个例子里，穿插并没什么问题。但有的情况下，解析第二个操作数是会影响第一个操作数的求值的，这时穿插就会造成问题。比如下面的例子：</p>
<pre><code class="language-lua">local t = { k = 1 }
local function f(t) t.k = 100; return 2 end -- 修改t.k的值
local r = t.k + f(t)*3
</code></pre>
<p>对于最后一句，我们预期是<code>1 + 2*3</code>，但是如果按照现在的求值顺序：</p>
<ol>
<li>先解析左操作数<code>t.k</code>，生成<code>ExpDesc::IndexField</code>，但并不discharge；</li>
<li>然后解析右操作数<code>f(t)*2</code>，在解析过程中会执行f(t)，从而修改t.k的值；</li>
<li>然后discharge左操作数，生成<code>GetField</code>字节码，但此时<code>t.k</code>已经被上一步修改了！这里就出现了错误。实际执行的就是<code>100 + 2*3</code>。</li>
</ol>
<p>综上，我们要确保两个操作数的字节码不能穿插！那么改造<code>exp_limit()</code>函数如下：</p>
<pre><code class="language-rust ignore">    fn exp_limit(&amp;mut self, limit: i32) -&gt; ExpDesc {
        // 这里省略原有的各种OTHERS类型处理

        loop {
            // 省略判断优先级的处理

            // discharge第一个操作数！！！
            if !matches!(desc, ExpDesc::Integer(_) | ExpDesc::Float(_) | ExpDesc::String(_)) {
                desc = ExpDesc::Local(self.discharge_top(desc));
            }

            // 继续解析
            let binop = self.lex.next();
            let right_desc = self.exp_limit(right_pri);  // 解析第二个操作数
            desc = self.process_binop(binop, desc, right_desc);
        }
    }
</code></pre>
<p>在解析第二个操作数前，先把第一个操作数discharge到栈上。不过对于常量类型则无需这么处理，因为：</p>
<ul>
<li>常量不会像上面的例子那样，被第二个操作数影响；</li>
<li>常量还要在后续尝试直接折叠。</li>
</ul>
<p>至此完成二元运算语法分析的<code>exp_limit()</code>函数改造。至于二元运算的具体处理<code>process_binop()</code>函数，下面介绍。</p>
<h2 id="字节码"><a class="header" href="#字节码">字节码</a></h2>
<p>上一节介绍的一元运算只有1个操作数，分2种情况：常量和变量，常量就直接求值，变量就生成字节码。所以每个一元运算都只有一个字节码。二元运算因为涉及2个操作数，所以复杂些。</p>
<p>首先，二元运算符虽然大部分都是数值计算，但因为Lua的元表功能，类似运算符重载，所以其他类型常量（比如字符串、bool等）都可能是合法的操作数。在解析一元运算时，这些类型的常量是直接报错，但对于二元运算需要到执行阶段才能判断是否合法。</p>
<p>其次，如果两个操作数都是数字类型常量（整数和浮点数），那么就可以在语法分析时直接计算出结果，称之为常量折叠。</p>
<p>否则，就生成字节码，由虚拟机执行。类似之前已经支持的<a href="./ch02-00.variables.html">读取全局变量</a>和<a href="./ch04-05.table_rw_and_bnf.html">读表</a>操作，每个二元运算符也都设置3个字节码，分别处理右操作数的3种类型：栈上变量、常量、小整数。</p>
<p>而左操作数统一discharge到栈上，因为左操作数是常量的情况并不多见。如果也为常量和小整数类型增加对应的字节码，比如<code>10-a</code>这种语句，那字节码类型就太多了。</p>
<p>最后，对于满足交换律的加法和乘法，如果左操作是常量，那么可以交换，比如<code>10+a</code>可以先转换为<code>a+10</code>，由于右操作数<code>10</code>是小整数，就可以使用<code>AddInt</code>字节码。</p>
<h2 id="expdesc"><a class="header" href="#expdesc">ExpDesc</a></h2>
<p>类似上一节介绍的一元运算引入的新ExpDesc类型，二元运算因为多了一个操作数，所以也需要一个新的类型：</p>
<pre><code class="language-rust ignore">enum ExpDesc {
    UnaryOp(fn(u8,u8)-&gt;ByteCode, usize), // (opcode, operand)
    BinaryOp(fn(u8,u8,u8)-&gt;ByteCode, usize, usize), // (opcode, left-operand, right-operand)
</code></pre>
<h2 id="语法分析"><a class="header" href="#语法分析">语法分析</a></h2>
<p>至此介绍完二元运算语句的基本要求。下面看代码实现，即<code>exp()</code>函数中调用的<code>process_binop()</code>函数：</p>
<pre><code class="language-rust ignore">    fn process_binop(&amp;mut self, binop: Token, left: ExpDesc, right: ExpDesc) -&gt; ExpDesc {
        if let Some(r) = fold_const(&amp;binop, &amp;left, &amp;right) { // 常量折叠
            return r;
        }

        match binop {
            Token::Add =&gt; self.do_binop(left, right, ByteCode::Add, ByteCode::AddInt, ByteCode::AddConst),
            Token::Sub =&gt; self.do_binop(left, right, ByteCode::Sub, ByteCode::SubInt, ByteCode::SubConst),
            Token::Mul =&gt; self.do_binop(left, right, ByteCode::Mul, ByteCode::MulInt, ByteCode::MulConst),
            // 省略更多类型
        }
    }
</code></pre>
<p>首先尝试常量折叠。这部分功能因为涉及整数和浮点数类型的处理，所以在下一节介绍。因为两个操作数并不一定是常量，并不一定能够折叠，如果没有成功折叠，那么后续还要使用操作符和两个操作数，所以这里<code>fold_const()</code>函数只能传入引用。</p>
<p>如果不是常量，不能折叠，那么调用<code>do_binop()</code>函数来返回ExpDesc。这里把enum的tag作为函数来使用，在<a href="./ch04-04.expdesc_rewrite.html#tableconstructor">之前</a>已经介绍过了，这里不再介绍。</p>
<p>下面来看<code>do_binop()</code>函数：</p>
<pre><code class="language-rust ignore">    fn do_binop(&amp;mut self, mut left: ExpDesc, mut right: ExpDesc, opr: fn(u8,u8,u8)-&gt;ByteCode,
            opi: fn(u8,u8,u8)-&gt;ByteCode, opk: fn(u8,u8,u8)-&gt;ByteCode) -&gt; ExpDesc {

        if opr == ByteCode::Add || opr == ByteCode::Mul { // commutative
            if matches!(left, ExpDesc::Integer(_) | ExpDesc::Float(_)) {
                // swap the left-const-operand to right, in order to use opi/opk
                (left, right) = (right, left);
            }
        }

        let left = self.discharge_top(left);

        let (op, right) = match right {
            ExpDesc::Integer(i) =&gt;
                if let Ok(i) = u8::try_from(i) {
                    (opi, i as usize)
                } else {
                    (opk, self.add_const(i))
                }
            ExpDesc::Float(f) =&gt; (opk, self.add_const(f)),
            _ =&gt; (opr, self.discharge_top(right)),
        };

        ExpDesc::BinaryOp(op, left, right)
    }
</code></pre>
<p>首先，判断如果是加法或乘法，并且左操作数是数字常量，则交换两个操作数，为了后续能够生成<code>xxCoust</code>或者<code>xxInt</code>的字节码。</p>
<p>然后，把左操作数discharge到栈上；</p>
<p>然后，再判断右操作数类型是否为数字常量，否则也discharge到栈上。</p>
<p>最后，生成<code>ExpDesc::BinaryOp</code>。</p>
<p>至此，二元运算语句的语法分析基本完成。</p>
<h2 id="整数和浮点数"><a class="header" href="#整数和浮点数">整数和浮点数</a></h2>
<p>至此，我们介绍了二元运算的大致解析过程，但还有一个细节，即对整数和浮点数类型的不同处理规则。由于这方面内容也不少，而且跟上述主要的解析过程相对独立，所以在下一节中单独介绍。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-01.unary_ops.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch05-03.int_and_float.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-01.unary_ops.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch05-03.int_and_float.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
