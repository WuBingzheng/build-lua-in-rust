<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>条件判断中的关系运算 - 用Rust实现Lua解释器</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">前言</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> 编译原理基础</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> 字节码</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> 值和类型</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html"><strong aria-hidden="true">1.4.</strong> 动手实现</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> 变量和赋值</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html"><strong aria-hidden="true">2.1.</strong> 更多类型</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html"><strong aria-hidden="true">2.2.</strong> 局部变量</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> 变量赋值</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> 字符串优化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> 字符串定义</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> 输入类型</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode和UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> 垃圾回收和Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> 表和ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> 表的定义</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> 表的构造</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc概念</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc改造</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> 表的读写和BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> 数值运算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> 一元运算</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html"><strong aria-hidden="true">5.2.</strong> 二元运算</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> 整数和浮点数</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> 控制结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if语句</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif和else分支</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while和break语句</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html"><strong aria-hidden="true">6.4.</strong> repeat和continue语句</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> 数值型for语句</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto语句</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> 逻辑运算和关系运算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html"><strong aria-hidden="true">7.1.</strong> 条件判断中的逻辑运算</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> 求值中的逻辑运算</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html" class="active"><strong aria-hidden="true">7.3.</strong> 条件判断中的关系运算</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> 求值中的关系运算</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> 函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> 定义和调用</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> 参数</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> 返回值</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html"><strong aria-hidden="true">8.4.</strong> Rust函数和API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> 尾调用</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> 闭包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue的逃逸和闭包</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> block和goto的逃逸</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust闭包</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> 泛型for语句</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> 环境 _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">未完待续</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">参考文献</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">用Rust实现Lua解释器</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="条件判断中的关系运算"><a class="header" href="#条件判断中的关系运算">条件判断中的关系运算</a></h1>
<p>前面两节介绍了逻辑运算，接下来两节介绍关系运算。</p>
<p>关系运算，即比较大小，共6个运算符：等于、不等、大于、小于、大于等于、小于等于。前两节介绍逻辑运算时说过，逻辑运算不能用第5章中的二元数值运算的解析流程，是因为短路这个特性。而关系运算也没有用第5章的解析流程，是不同的原因：为了性能。</p>
<p>如果不考虑性能，关系运算是可以用第5章的解析流程的。比如对于等于运算，可以生成如下字节码：<code>EQ $r $a $b</code>，即比较a和b，并把布尔类型的结果赋值给r。如果要考虑性能，就要看关系运算的应用场景。这部分跟前两节介绍的逻辑运算几乎一样，也有两个应用场景：</p>
<ol>
<li>作为判断条件，比如上一章中if、while等语句中的判断条件语句，比如<code>if a == b then ...</code>；</li>
<li>求值，比如<code>print(a == b)</code>。</li>
</ol>
<p>跟逻辑运算一样，第1种场景可以看做是第2种场景的简化版，不需要具体求值，只需要判断真假。比如上述的if语句例子，也可以按照第2种场景来解释，认为是先对<code>a == b</code>求值到临时变量，然后再判断临时变量是否为真，来决定是否跳转。这里可以省去临时变量！由于关系运算大部分应用是第1种场景，所以是值得把这个场景从第2种通用场景中独立出来特地做优化的，通过省去临时变量，直接根据求值结果来判断是否跳转。</p>
<p>如本节标题所示，本节只介绍第1种场景；下一节再介绍第2种场景。</p>
<h2 id="字节码"><a class="header" href="#字节码">字节码</a></h2>
<p>还是用if语句和等于运算为例，在<code>if a == b then ... end</code>场景下，最先想到的字节码序列如下：</p>
<pre><code>EQ   $tmp $a $b  # 比较a和b是否相等，结果存在临时变量中
TEST $tmp $jmp   # 根据临时变量来决定是否跳转
</code></pre>
<p>现在要省去临时变量$tmp，合并两条字节码，如下：</p>
<pre><code>EQ   $a $b $jmp  # 比较a和b是否相等，来决定是否跳转
</code></pre>
<p>但问题是这样需要3个参数，留给最后的跳转参数的只有1个字节的空间，表示范围太小了。为此可以再拆成2个字节码：</p>
<pre><code>EQ   $a $b  # 判断a和b是否相等，如果相等则跳过下一条语句，即pc++
JUMP $jmp   # 无条件跳转
</code></pre>
<p>这样就可以用2个字节来表示跳转参数了。但是，既然还是需要2条字节码，那跟最开始的“EQ+TEST”方案，又有什么区别呢？搞这么复杂是为了什么呢？</p>
<ul>
<li>
<p>虚拟机执行时，如果判断a和b相等，跳过下面JUMP字节码，那么就只执行了1条字节码；而最开始的“EQ+TEST”方案总是会执行2条字节码。对于if语句判断为真的概率不知道，但对于while语句判断为真的概率还是很大的，所以这里相当于是大概率省去了1条字节码的执行；</p>
</li>
<li>
<p>即便判断为假，需要执行下面的JUMP字节码，那么也可以在执行EQ字节码的时候，直接读取下一条字节码，而不用再走一次指令分发。这里的JUMP字节码相当于是EQ字节码的扩展参数，而不是一条独立执行的字节码。Lua的官方实现就是这么做的，这也是因为C语言中可以忽略字节码的类型，通过位运算直接读取字节码中的参数。但是在Rust语言中如果不用unsafe，是不能忽略enum的tag而直接读取参数的，所以我们的解释器里不能实现这个优化。</p>
</li>
<li>
<p>根据判断结果可以直接决定是否跳转。而最开始的“EQ+TEST”方案，需要先把判断结果写入栈上临时变量，然后在TEST字节码执行时再读取临时变量，然后再次判断真假，这样就多了一次临时变量的读和写，也多了一次真假的判断。</p>
</li>
</ul>
<p>优势呢就是这么个优势。有，但不多。尤其是跟其带来的实现复杂度相比，就更显得少了。最开始的“EQ+TEST”方案只需要在之前介绍的<a href="./ch05-02.binary_ops.html">二元数值运算</a>中，增加几个运算符即可；但新的方案需要跟前面讲的逻辑运算配合。不过我们还是选择跟随Lua官方实现，用实现的复杂度换一些执行效率优化。</p>
<p>另外，关于字节码中两个操作数的类型，按照之前<a href="./ch04-05.table_rw_and_bnf.html#%E6%89%A7%E8%A1%8C%E8%B5%8B%E5%80%BC">字节码参数类型</a>的说明，跟二元数值运算的字节码相似，每个关系运算符也都对应3个字节码，比如对于相等运算符有：<code>Equal</code>、<code>EqualInt</code>和<code>EqualConst</code>共3个字节码。一共6个关系运算符，就是18个字节码。</p>
<h2 id="跟逻辑运算相结合"><a class="header" href="#跟逻辑运算相结合">跟逻辑运算相结合</a></h2>
<p>关系运算和逻辑运算相结合是非常常见的。以<code>a&gt;b and b&lt;c</code>语句为例，按照前面两节的介绍，这是一条逻辑运算语句，两个操作数分别是<code>a&gt;b</code>和<code>b&lt;c</code>，需要把这两个操作数discharge到栈上临时变量以便判断真假。这里为了避免使用临时变量，就需要让关系运算和逻辑运算互相配合。</p>
<p>对于关系运算语句，需要新增ExpDesc类型：<code>Compare</code>。下面来看如果要跟逻辑运算相结合，即对于以关系运算为操作数的逻辑运算语句，那么这个类型需要关联什么参数。</p>
<p>首先，如果不转换为<code>ExpDesc::Test</code>类型，那么<code>Compare</code>类型就需要自己维护True和False两条跳转链表；</p>
<p>其次，对于True和False这两种跳转，之前的逻辑运算是通过2个字节码来区分的，<code>TestAndJump</code>和<code>TestOrJump</code>。对于关系运算，也可以这么做，比如等于运算用<code>EqualTrue</code>和<code>EqualFalse</code>字节码。但是关系运算符一共有18个字节码，如果还要每个字节码都再区分True和False跳转，那么需要36个字节码了。这就太多了。还好有另外一种方法，上面介绍的<code>EQ</code>字节码只有2个参数，可以再增加一个布尔类型的参数，来表示True还是False跳转。</p>
<p>最后，对于True和False这两种跳转，是需要根据<strong>后面</strong>的逻辑运算符来决定的。比如上面的<code>a&gt;b and b&lt;c</code>的例子，在解析到<code>a&gt;b</code>时还不能确定，只有解析到<code>and</code>时才能确定。所以在解析关系运算语句时还不能生成完整的字节码，就只能先把相关信息存入<code>Compare</code>类型中，然后在确定跳转类型后，再生成字节码。</p>
<p>综上，关系运算的新类型定义如下：</p>
<pre><code class="language-rust ignore">enum ExpDesc {
    Compare(fn(u8,u8,bool)-&gt;ByteCode, usize, usize, Vec&lt;usize&gt;, Vec&lt;usize&gt;),
</code></pre>
<p>前面3个参数是字节码类型和前2个参数，用于在确定跳转类型后以生成字节码；后面2个参数是True和False跳转列表。整个类型相当于是<code>BinaryOp</code>和<code>Test</code>类型的结合。</p>
<p>这里跟前面介绍的逻辑运算遇到的是同样的问题，都是在生成字节码的时候还不能确定跳转的目的地址，不能立即生成完整的字节码，需要后续确定目的地址后再处理。但是，这里跟之前的逻辑运算的解决方法不一样。之前的逻辑运算的做法是：先生成一个字节码占位，而只把跳转目的地址的参数留空；后续确定目的地址后再修复字节码中的对应参数（<code>fix_test_list()</code>函数）。而这里的关系运算的做法是，把信息都存到<code>ExpDesc::Compare</code>中（导致这个类型的定义很长），然后等后续确定目的地址后再直接生成完整的字节码。</p>
<p>其实对于关系运算的处理，理论上也可以采用逻辑运算那种先生成字节码再修复的方法，但是关系运算对应的字节码有18个，太多了，如果还按照<code>fix_test_list()</code>函数的做法先匹配再生成字节码，代码就显得太复杂了。如果是在C语言中，可以通过位操作直接修正字节码内的参数，而忽略字节码类型；而在Rust中直接修改enum内关联参数就需要unsafe了。</p>
<p>另外一个区别是，在解析逻辑运算时，必须立即生成字节码用来占位。而关系运算的<code>Compare</code>类型操作数会在紧接着的<code>test_or_jump()</code>函数中就确定跳转类型，就可以生成字节码了，所以并不需要占位，也就没必要先生成字节码然后再修复了。</p>
<h2 id="语法分析"><a class="header" href="#语法分析">语法分析</a></h2>
<p>关系运算的语法分析分为两部分：</p>
<ul>
<li>
<p>解析运算本身，根据运算符生成对应的<code>ExpDesc::Compare</code>，这部分跟<a href="./ch05-02.binary_ops.html">二元数值运算</a>类似，这里略过。</p>
</li>
<li>
<p>关系运算和逻辑运算的结合，即<code>ExpDesc::Compare</code>和<code>ExpDesc::Test</code>的结合。在之前逻辑运算解析部分，都增加对<code>ExpDesc::Compare</code>的处理。</p>
</li>
</ul>
<p>比如在逻辑运算左操作数时，生成字节码，并处理两条跳转列表：</p>
<pre><code class="language-rust ignore">    fn test_or_jump(&amp;mut self, condition: ExpDesc) -&gt; Vec&lt;usize&gt; {
        let (code, true_list, mut false_list) = match condition {
            ExpDesc::Boolean(true) | ExpDesc::Integer(_) | ExpDesc::Float(_) | ExpDesc::String(_) =&gt; {
                return Vec::new();
            }
            // 新增Compare类型。
            // 生成2个字节码。
            // 两个跳转列表的处理方式跟下面的`ExpDesc::Test`的一样。
            ExpDesc::Compare(op, left, right, true_list, false_list) =&gt; {
                // 确定为True跳转，即关联的第3个参数，就可以生成完整字节码。
                self.byte_codes.push(op(left as u8, right as u8, true));

                // 生成Jump字节码，但还不知道跳转目的地址，需要后续修复。为此，
                // fix_test_list()中要新增对Jump字节码的处理。
                (ByteCode::Jump(0), Some(true_list), false_list)
            }
            ExpDesc::Test(condition, true_list, false_list) =&gt; {
                let icondition = self.discharge_any(*condition);
                (ByteCode::TestOrJump(icondition as u8, 0), Some(true_list), false_list)
            }
            _ =&gt; {
                let icondition = self.discharge_any(condition);
                (ByteCode::TestOrJump(icondition as u8, 0), None, Vec::new())
            }
        };
</code></pre>
<p>在比如在处理右操作数时：</p>
<pre><code class="language-rust ignore">    fn process_binop(&amp;mut self, binop: Token, left: ExpDesc, right: ExpDesc) -&gt; ExpDesc {
        match binop {
            Token::And | Token::Or =&gt; {
                if let ExpDesc::Test(_, mut left_true_list, mut left_false_list) = left {
                    match right {
                        // 新增Compare类型。
                        // 处理方式类似下面的`ExpDesc::Test`类型。
                        ExpDesc::Compare(op, l, r, mut right_true_list, mut right_false_list) =&gt; {
                            left_true_list.append(&amp;mut right_true_list);
                            left_false_list.append(&amp;mut right_false_list);
                            ExpDesc::Compare(op, l, r, left_true_list, left_false_list)
                        }
                        ExpDesc::Test(condition, mut right_true_list, mut right_false_list) =&gt; {
                            left_true_list.append(&amp;mut right_true_list);
                            left_false_list.append(&amp;mut right_false_list);
                            ExpDesc::Test(condition, left_true_list, left_false_list)
                        }
                        _ =&gt; ExpDesc::Test(Box::new(right), left_true_list, left_false_list),
                    }
                } else {
                    panic!(&quot;impossible&quot;);
                }
            }
</code></pre>
<h2 id="虚拟机执行"><a class="header" href="#虚拟机执行">虚拟机执行</a></h2>
<p>一共6种关系运算符。由于我们之前已经为<code>Value</code>实现了<code>Eq</code> trait，所以其中的等于和不等于运算可以使用<code>==</code>和<code>!=</code>来直接比较Value操作数。但对于另外4个运算符，就需要再给<code>Value</code>实现新的trait了，就是<code>PartialOrd</code>。之所以不是<code>Ord</code>是因为不同类型的Value是不能比较大小的。而不需要使用<code>PartialEq</code>是因为不同类型的Value是可以比较是否相等的，返回结果为False。比如对下面两条语句：</p>
<pre><code class="language-lua">print (123 == 'hello') -- 打印false
print (123 &gt; 'hello')  -- 抛异常
</code></pre>
<p>Lua的大小比较运算符，只支持数字和字符串类型。所以<code>Value</code>的<code>PartialOrd</code>实现如下：</p>
<pre><code class="language-rust ignore">impl PartialOrd for Value {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
        match (self, other) {
            // numbers
            (Value::Integer(i1), Value::Integer(i2)) =&gt; Some(i1.cmp(i2)),
            (Value::Integer(i), Value::Float(f)) =&gt; (*i as f64).partial_cmp(f),
            (Value::Float(f), Value::Integer(i)) =&gt; f.partial_cmp(&amp;(*i as f64)),
            (Value::Float(f1), Value::Float(f2)) =&gt; f1.partial_cmp(f2),

            // strings
            (Value::ShortStr(len1, s1), Value::ShortStr(len2, s2)) =&gt; Some(s1[..*len1 as usize].cmp(&amp;s2[..*len2 as usize])),
            (Value::MidStr(s1), Value::MidStr(s2)) =&gt; Some(s1.1[..s1.0 as usize].cmp(&amp;s2.1[..s2.0 as usize])),
            (Value::LongStr(s1), Value::LongStr(s2)) =&gt; Some(s1.cmp(s2)),

            // strings of different types
            (Value::ShortStr(len1, s1), Value::MidStr(s2)) =&gt; Some(s1[..*len1 as usize].cmp(&amp;s2.1[..s2.0 as usize])),
            (Value::ShortStr(len1, s1), Value::LongStr(s2)) =&gt; Some(s1[..*len1 as usize].cmp(s2)),
            (Value::MidStr(s1), Value::ShortStr(len2, s2)) =&gt; Some(s1.1[..s1.0 as usize].cmp(&amp;s2[..*len2 as usize])),
            (Value::MidStr(s1), Value::LongStr(s2)) =&gt; Some(s1.1[..s1.0 as usize].cmp(s2)),
            (Value::LongStr(s1), Value::ShortStr(len2, s2)) =&gt; Some(s1.as_ref().as_slice().cmp(&amp;s2[..*len2 as usize])),
            (Value::LongStr(s1), Value::MidStr(s2)) =&gt; Some(s1.as_ref().as_slice().cmp(&amp;s2.1[..s2.0 as usize])),

            (_, _) =&gt; None,
        }
    }
}
</code></pre>
<p>对于浮点数需要调用<code>partial_cmp()</code>方法是因为浮点数的Nan不能比较大小。</p>
<p>实现了<code>PartialOrd</code> trait的类型就可以直接使用<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>和<code>&lt;=</code>等几个比较大小的符号了。但是<code>PartialOrd</code>对于大小比较其实有3个返回结果：真、假、和不能比较。对应于Lua语言就分别是真、假、和抛出异常。而上述4个比较符号只能给出2个结果，对于不能比较的情况也是返回假。所以为了能判断出不能比较的情况，我们不能直接使用这4个符号，还是要用原始的<code>partial_cmp()</code>函数。下面是<code>LesEq</code>和<code>Less</code>两个字节码的执行代码：</p>
<pre><code class="language-rust ignore">    ByteCode::LesEq(a, b, r) =&gt; {
        let cmp = &amp;self.stack[a as usize].partial_cmp(&amp;self.stack[b as usize]).unwrap();
        if !matches!(cmp, Ordering::Greater) == r {
            pc += 1;
        }
    }
    ByteCode::Less(a, b, r) =&gt; {
        let cmp = &amp;self.stack[a as usize].partial_cmp(&amp;self.stack[b as usize]).unwrap();
        if matches!(cmp, Ordering::Less) == r {
            pc += 1;
        }
    }
</code></pre>
<p>这里用<code>unwarp()</code>来抛出异常。后续在规范错误处理时，这里需要做改进。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-02.logical_in_evalue.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch07-04.relational_in_evalue.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-02.logical_in_evalue.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch07-04.relational_in_evalue.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
