<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>More Types - Build a Lua Interpreter in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> Basic Compilation Principles</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> Value and Type</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html"><strong aria-hidden="true">1.4.</strong> Let's Do It!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> Variables and Assignments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html" class="active"><strong aria-hidden="true">2.1.</strong> More Types</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html"><strong aria-hidden="true">2.2.</strong> Local Variables</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> Variable Assignment</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> String Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> String Definition</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> Type Conversion</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> Input Type</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode and UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> Garbage Collection and Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> Table and ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> Table Definition</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> Table Construction</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc Concept</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc Rewrite</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> Table Read/Write and BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> Numerical Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> Unary Operations</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html"><strong aria-hidden="true">5.2.</strong> Binary Operations</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> Integer and Float</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> Control Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if Statement</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif and else Branches</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while and break Statements</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html"><strong aria-hidden="true">6.4.</strong> repeat and continue Statements</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> numerical-for Statement</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto Statement</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> Logical and Relational Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html"><strong aria-hidden="true">7.1.</strong> Logical Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> Logical Operations in Evalue</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html"><strong aria-hidden="true">7.3.</strong> Relational Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> Relational Operations in Evalue</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> Function</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> Definition and Call</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> Return Value</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html"><strong aria-hidden="true">8.4.</strong> Rust Functions and API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> Tail Call</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> Closure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue Escape and Closure</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> Escape from Block and goto</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust Closures</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> generic-for Statement</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> Environment _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">To Be Continued</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build a Lua Interpreter in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="more-types"><a class="header" href="#more-types">More Types</a></h1>
<p>This section adds simple types, including boolean, integer, and float. Other types such as Table and UserData will be implemented in subsequent chapters.</p>
<p>We first improve the lexical analysis to support the tokens corresponding to these types, and then generate the corresponding bytecodes through the syntax analysis, and add support for these bytecodes in the virtual machine. Finally we modify the function call to support printing these types.</p>
<h2 id="improve-lexical-analysis"><a class="header" href="#improve-lexical-analysis">Improve Lexical Analysis</a></h2>
<p>The lexical analysis in the previous chapter only supports 2 tokens. So now no matter what features are added, the lexical analysis must be changed first to add the corresponding Tokens. In order to avoid adding tokens piecemeal in each chapter in the future, it is now added here in one go.</p>
<p>The Lua official website lists the complete <a href="https://www.lua.org/manual/5.4/manual.html#3.1">lexical conventions</a>. It includes:</p>
<ul>
<li>
<p>Name, which has been implemented before, is used for variables, etc.</p>
</li>
<li>
<p>Constants, including string, integer, and floating-point constants.</p>
</li>
<li>
<p>Keywords:</p>
<pre><code>  and break do else else if end
  false for function goto if in
  local nil not or repeat return
  then true until while
</code></pre>
</li>
<li>
<p>Symbols:</p>
<pre><code>  + - * / % ^ #
  &amp; ~ | &lt;&lt; &gt;&gt; //
  == ~= &lt;= &gt;= &lt; &gt; =
  ( ) { } [ ] ::
  ; : , . .. ...
</code></pre>
</li>
</ul>
<p>The corresponding Token is defined as:</p>
<pre><code class="language-rust  ignore">#[derive(Debug, PartialEq)]
pub enum Token {
    // keywords
    And,    Break,  Do,     Else,   Elseif, End,
    False,  For,    Function, Goto, If,     In,
    Local,  Nil,    Not,    Or,     Repeat, Return,
    Then,   True,   Until,  While,

 // +       -       *       /       %       ^       #
    Add,    Sub,    Mul,    Div,    Mod,    Pow,    Len,
 // &amp;       ~       |       &lt;&lt;      &gt;&gt;      //
    BitAnd, BitXor, BitOr,  ShiftL, ShiftR, Idiv,
 // ==       ~=     &lt;=      &gt;=      &lt;       &gt;        =
    Equal,  NotEq,  LesEq,  GreEq,  Less,   Greater, Assign,
 // (       )       {       }       [       ]       ::
    ParL,   ParR,   CurlyL, CurlyR, SqurL,  SqurR,  DoubColon,
 // ;               :       ,       .       ..      ...
    SemiColon,      Colon,  Comma,  Dot,    Concat, Dots,

    // constant values
    Integer(i64),
    Float(f64),
    String(String),

    // name of variables or table keys
    Name(String),

    // end
    Eos,
}</code></pre>
<p>The specific implementation is nothing more than tedious string parsing, which is skipped here. For the sake of simplicity, this implementation only supports most simple types, but does not support complex types such as long strings, long comments, string escapes, hexadecimal numbers, and floating point numbers only support scientific notation Law. These do not affect the main features to be added later.</p>
<h2 id="type-of-values"><a class="header" href="#type-of-values">Type of Values</a></h2>
<p>After lexical analysis supports more types, we add these types to Value:</p>
<pre><code class="language-rust  ignore">#[derive(Clone)]
pub enum Value {
    Nil,
    Boolean(bool),
    Integer(i64),
    Float(f64),
    String(String),
    Function(fn (&amp;mut ExeState) -&gt; i32),
}

impl fmt::Debug for Value {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; Result&lt;(), fmt::Error&gt; {
        match self {
            Value::Nil =&gt; write!(f, &quot;nil&quot;),
            Value::Boolean(b) =&gt; write!(f, &quot;{b}&quot;),
            Value::Integer(i) =&gt; write!(f, &quot;{i}&quot;),
            Value::Float(n) =&gt; write!(f, &quot;{n:?}&quot;),
            Value::String(s) =&gt; write!(f, &quot;{s}&quot;),
            Value::Function(_) =&gt; write!(f, &quot;function&quot;),
        }
    }
}</code></pre>
<p>One of the special places is that the debug mode is used for the output of floating-point numbers: <code>{:?}</code>. Because Rust's common output format <code>{}</code> for floating-point numbers is integer + decimal format, and a more reasonable way should be to choose a more suitable one between &quot;integer decimal&quot; and &quot;scientific notation&quot;, corresponding to <code>%g</code> in C language's <code>printf</code>. For example, it is unreasonable to output <code>&quot;0.000000&quot;</code> for the number <code>1e-10</code>. This seems to be a <a href="https://internals.rust-lang.org/t/pre-rfc-draft-g-or-floating-points-for-humans/9110">historical issue</a> of Rust. For compatibility and other reasons, only the debug mode <code>{:?}</code> can be used to correspond to <code>%g</code>. I don't get into it here.</p>
<p>In addition, in order to facilitate the distinction between &quot;integer&quot; and &quot;floating point number without decimal part&quot;, in Lua's official implementation, <code>.0</code> will be added after the latter. For example, <code>2</code> will be output as <code>2.0</code> for the floating point number. The code is as follows. This is so sweet. And this is also the default behavior of Rust's <code>{:?}</code> mode, so we don't need special handling for this.</p>
<pre><code class="language-c">     if (buff[strspn(buff, &quot;-0123456789&quot;)] == '\0') { /* looks like an int? */
       buff[len++] = lua_getlocaledecpoint();
       buff[len++] = '0'; /* adds '.0' to result */
     }
</code></pre>
<blockquote>
<p>Before <a href="http://www.lua.org/versions.html#5.3">Lua 5.3</a>, Lua has only one numeric type, the default is floating point. I understand this because Lua was originally intended for configuration files, for users rather than programmers. For ordinary users, the concepts of integer and floating point numbers are not distinguished, and there is no difference between configuring <code>10 seconds</code> and <code>10.0 seconds</code>; in addition, for some calculations, such as <code>7/2</code>, the result is obviously <code>3.5</code> and Not <code>3</code>. However, with the expansion of Lua's use, for example, as a glue language between many large programs, the demand for integers has become increasingly strong, so integers and floating-point numbers are distinguished at the language level.</p>
</blockquote>
<h2 id="syntax-analysis"><a class="header" href="#syntax-analysis">Syntax Analysis</a></h2>
<p>Now we add support for these types in the parser. Since currently only the function call statement is supported, that is, the format of <code>function parameter</code>; and the &quot;function&quot; only supports global variables, so this time only the &quot;parameter&quot; part needs to support these new types. For function calls in Lua voice, if the parameter is a string constant or a table structure, then the parentheses <code>()</code> can be omitted, as in the &quot;hello, world!&quot; example in the previous chapter. But for other cases, such as several new types added this time, brackets <code>()</code> must be required. So the modification of the parameter part is as follows:</p>
<pre><code class="language-rust  ignore">Token::Name(name) =&gt; {
     // function, global variable only
     let ic = add_const(&amp;mut constants, Value::String(name));
     byte_codes.push(ByteCode::GetGlobal(0, ic as u8));

     // argument, (var) or &quot;string&quot;
     match lex. next() {
         Token::ParL =&gt; { // '('
             let code = match lex. next() {
                 Token::Nil =&gt; ByteCode::LoadNil(1),
                 Token::True =&gt; ByteCode::LoadBool(1, true),
                 Token::False =&gt; ByteCode::LoadBool(1, false),
                 Token::Integer(i) =&gt;
                     if let Ok(ii) = i16::try_from(i) {
                         ByteCode::LoadInt(1, ii)
                     } else {
                         load_const(&amp;mut constants, 1, Value::Integer(i))
                     }
                 Token::Float(f) =&gt; load_const(&amp;mut constants, 1, Value::Float(f)),
                 Token::String(s) =&gt; load_const(&amp;mut constants, 1, Value::String(s)),
                 _ =&gt; panic!(&quot;invalid argument&quot;),
             };
             byte_codes. push(code);

             if lex.next() != Token::ParR { // ')'
                 panic!(&quot;expected `)`&quot;);
             }
         }
         Token::String(s) =&gt; {
             let code = load_const(&amp;mut constants, 1, Value::String(s));
             byte_codes. push(code);
         }
         _ =&gt; panic!(&quot;expected string&quot;),
     }
}</code></pre>
<p>This code first parses the function. Like the code in the previous chapter, it still only supports global variables. Then parse the parameters. In addition to the support for string constants, a more general way of parentheses <code>()</code> is added. Which handles various type constants:</p>
<ul>
<li>
<p>Floating-point constants, similar to string constants, call the <code>load_const()</code> function, put it in the constant table at compile time, and then load it through <code>LoadConst</code> bytecode during execution.</p>
</li>
<li>
<p>Nil and Boolean types, there is no need to put Nil, true and false in the constant table. It is more convenient to encode directly into bytecode, and it is faster at execution time (because there is one less memory read). So <code>LoadNil</code> and <code>LoadBool</code> bytecodes are added.</p>
</li>
<li>
<p>Integer constants combine the above two approaches. Because a bytecode has 4 bytes, the opcode occupies 1 byte, the destination address occupies 1 byte, and there are 2 bytes left, which can store the integer of <code>i16</code>. Therefore, for numbers in the range of <code>i16</code> (this is also a high probability event), it can be directly encoded into the bytecode, and the <code>LoadInt</code> bytecode is added for this purpose; if it exceeds the range of <code>i16</code>, it is stored in the constant table . This is also the official implementation of Lua for reference. From this we can see Lua's pursuit of performance, it adds a bytecode and process codes in order to reduce a memory access only. We will see many such cases in the future.</p>
</li>
</ul>
<p>Since only the function call statment is currently supported, the function is fixed at the <code>0</code> position of the stack during execution, and the parameter is fixed at the <code>1</code> position. The target addresses of the above bytecodes are also fixedly filled with <code>1</code>.</p>
<p>The main code has been introduced. The definition of the function <code>load_const()</code> used to generate <code>LoadConst</code> bytecode is listed below:</p>
<pre><code class="language-rust  ignore">fn add_const(constants: &amp;mut Vec&lt;Value&gt;, c: Value) -&gt; usize {
     constants. push(c)
}

fn load_const(constants: &amp;mut Vec&lt;Value&gt;, dst: usize, c: Value) -&gt; ByteCode {
     ByteCode::LoadConst(dst as u8, add_const(constants, c) as u8)
}</code></pre>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>So far, the parsing process has completed the support for new types. The rest of the virtual machine execution part just supports the newly added bytecode <code>LoadInt</code>, <code>LoadBool</code> and <code>LoadNil</code>. Skip it here.</p>
<p>Then you can test the following code:</p>
<pre><code class="language-lua">print(nil)
print(false)
print(123)
print(123456)
print(123456.0)
</code></pre>
<p>The output is as follows:</p>
<pre><code>[src/parse.rs:64] &amp;constants = [
     print,
     print,
     print,
     print,
     123456,
     print,
     123456.0,
]
byte_codes:
   GetGlobal(0, 0)
   LoadNil(1)
   Call(0, 1)
   GetGlobal(0, 0)
   LoadBool(1, false)
   Call(0, 1)
   GetGlobal(0, 0)
   LoadInt(1, 123)
   Call(0, 1)
   GetGlobal(0, 0)
   LoadConst(1, 1)
   Call(0, 1)
   GetGlobal(0, 0)
   LoadConst(1, 2)
   Call(0, 1)
nil
false
123
123456
123456.0
</code></pre>
<p>There is a small problem left over from the last chapter, that is, <code>print</code> appears many times in the constant table. This needs to be modified to check whether it already exists every time a constant is added.</p>
<h2 id="add-constants"><a class="header" href="#add-constants">Add Constants</a></h2>
<p>Modify the <code>add_const()</code> function above as follows:</p>
<pre><code class="language-rust  ignore">fn add_const(constants: &amp;mut Vec&lt;Value&gt;, c: Value) -&gt; usize {
     constants.iter().position(|v| v == &amp;c)
         .unwrap_or_else(|| {
             constants. push(c);
             constants.len() - 1
         })
}</code></pre>
<p><code>constants.iter().position()</code> positions the index. Its parameter is a <a href="https://doc.rust-lang.org/stable/book/ch13-01-closures.html">closure</a>, which needs to compare two <code>Value</code>, for which <code>Value</code> needs to be implemented <code>PartialEq</code> trait:</p>
<pre><code class="language-rust  ignore">impl PartialEq for Value {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        // TODO compare Integer vs Float
        match (self, other) {
            (Value::Nil, Value::Nil) =&gt; true,
            (Value::Boolean(b1), Value::Boolean(b2)) =&gt; *b1 == *b2,
            (Value::Integer(i1), Value::Integer(i2)) =&gt; *i1 == *i2,
            (Value::Float(f1), Value::Float(f2)) =&gt; *f1 == *f2,
            (Value::String(s1), Value::String(s2)) =&gt; *s1 == *s2,
            (Value::Function(f1), Value::Function(f2)) =&gt; std::ptr::eq(f1, f2),
            (_, _) =&gt; false,
        }
    }
}</code></pre>
<p>Here we think that two integers and floating point numbers that are numerically equal are different, such as <code>Integer(123456)</code> and <code>Float(123456.0)</code>, because these are indeed two values, and the two cannot be combined when dealing with constant tables value, otherwise in the test code in the previous section, the last line will also load the integer <code>123456</code>.</p>
<p>But during Lua execution, these two values are equal, that is, the result of <code>123 == 123.0</code> is <code>true</code>. We will deal with this issue in a later chapter.</p>
<p>Going back to the <code>position()</code> function, its return value is <code>Option&lt;usize&gt;</code>, <code>Some(i)</code> means found, and returns the index directly; while <code>None</code> means not found, you need to add a constant first, and then return the index. According to the programming habit of C language, it is the following if-else judgment, but here we try to use a more functional way. Personally, I feel that this method is not clearer, but since you are learning Rust, try to use the Rust method first.</p>
<pre><code class="language-rust  ignore">     if let Some(i) = constants.iter().position(|v| v == &amp;c) {
         i
     } else {
         constants. push(c);
         constants.len() - 1
     }</code></pre>
<p>After completing the transformation of the <code>add_const()</code> function, duplicate values can be avoided in the constant table. The relevant output is intercepted as:</p>
<pre><code>[src/parse.rs:64] &amp;constants = [
     print,
     123456,
     123456.0,
]
</code></pre>
<p>Although the above will check for duplicates when adding constants, the check is done by traversing the array. The time complexity of adding all constants is O(N^2). If a Lua code segment contains a lot of constants, such as 1 million, the parsing will be too slow. For this we need a hash table to provide fast lookups. TODO.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch02-00.variables.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch02-02.local.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch02-00.variables.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch02-02.local.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
